```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valentine?</title>
  <style>
    * { box-sizing: border-box; }
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:#fff;
      background: radial-gradient(1200px 800px at 50% 30%, #2a1b2a 0%, #0f1020 55%, #070812 100%);
      overflow:hidden;
    }

    .card{
      width:min(900px,92vw);
      padding:clamp(20px,4vw,44px);
      border-radius:28px;
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.12);
      box-shadow:0 20px 80px rgba(0,0,0,0.45);
      text-align:center;
      position:relative;
      backdrop-filter:blur(10px);
    }

    h1{
      margin:0 0 10px 0;
      font-size:clamp(34px,5vw,64px);
      line-height:1.05;
      letter-spacing:-0.02em;
      text-shadow:0 10px 30px rgba(0,0,0,0.35);
    }

    .sub{
      margin:0 0 26px 0;
      font-size:clamp(16px,2vw,20px);
      opacity:0.9;
    }

    .btn-row{
      display:flex;
      justify-content:center;
      align-items:center;
      gap:18px;
      flex-wrap:wrap;
      margin-top:6px;
      min-height:74px;
    }

    button{
      border:0;
      cursor:pointer;
      font-weight:900;
      border-radius:999px;
      padding:18px 42px;
      font-size:24px;
      letter-spacing:0.02em;
      transition:transform 0.08s ease, filter 0.12s ease;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      touch-action: manipulation;
    }
    button:active{ transform:scale(0.98); }

    #yesBtn{
      background:linear-gradient(135deg,#ff4d7d,#ff1f5a);
      color:#fff;
      box-shadow:0 18px 50px rgba(255,31,90,0.35);
    }
    #yesBtn:hover{ filter:brightness(1.05); }

    /* NO button: same size as YES, fixed + moved by JS */
    #noBtn{
      position:fixed;
      left:20px;
      top:20px;
      transform:none;
      background:rgba(255,255,255,0.18);
      color:#fff;
      border:1px solid rgba(255,255,255,0.25);
      box-shadow:0 14px 40px rgba(0,0,0,0.25);
      z-index:10;
      will-change: left, top;
    }

    .hint{
      margin-top:22px;
      font-size:14px;
      opacity:0.75;
    }

    /* Popup */
    .modal{
      position:fixed;
      inset:0;
      display:none;
      place-items:center;
      background:rgba(0,0,0,0.55);
      z-index:60;
    }
    .modal.show{ display:grid; }
    .modal-card{
      width:min(520px,92vw);
      padding:26px 26px 22px;
      border-radius:22px;
      background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.18);
      backdrop-filter:blur(12px);
      text-align:center;
      box-shadow:0 30px 120px rgba(0,0,0,0.55);
    }
    .modal-card h2{ margin:0 0 10px 0; font-size:34px; }
    .modal-card p{ margin:0 0 18px 0; opacity:0.9; }
    .close{
      background:rgba(255,255,255,0.18);
      color:#fff;
      padding:12px 18px;
      font-size:16px;
      border:1px solid rgba(255,255,255,0.2);
      border-radius:999px;
      font-weight:800;
    }

    /* Confetti canvas */
    canvas#confetti{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:50;
    }

    /* Party popper burst (emoji particles) */
    .burst{
      position:fixed;
      left:50%;
      top:52%;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:70;
      font-size:34px;
      filter: drop-shadow(0 12px 18px rgba(0,0,0,0.4));
    }
    @keyframes pop {
      0%   { transform: translate(-50%,-50%) scale(0.6); opacity:0; }
      12%  { opacity:1; }
      60%  { transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(1.2); opacity:1; }
      100% { transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(1.0); opacity:0; }
    }
  </style>
</head>

<body>
  <canvas id="confetti"></canvas>

  <div class="card">
    <h1><span id="name">Anusha</span>, will you be my Valentine? üíñ</h1>
    <p class="sub">Be honest‚Ä¶ but the universe might have other plans üòÑ</p>

    <div class="btn-row">
      <button id="yesBtn">YES üíò</button>
      <button id="noBtn">NO</button>
    </div>

    <div class="hint">(Try pressing ‚ÄúNO‚Äù if you dare.)</div>
  </div>

  <div class="modal" id="modal" role="dialog" aria-modal="true" aria-labelledby="mTitle">
    <div class="modal-card">
      <h2 id="mTitle">Ok! It‚Äôs a date!! üíû</h2>
      <p>Now go tell Ajay what time üòå</p>
      <button class="close" id="closeBtn">Awww ‚ù§Ô∏è</button>
    </div>
  </div>

<script>
  // Optional: set name via URL like ?name=Anusha
  const params = new URLSearchParams(location.search);
  const nm = params.get("name");
  if (nm) document.getElementById("name").textContent = nm;

  const noBtn = document.getElementById("noBtn");
  const yesBtn = document.getElementById("yesBtn");
  const modal = document.getElementById("modal");
  const closeBtn = document.getElementById("closeBtn");

  // Ensure NO never "disappears" due to any accidental styles
  function forceVisibleNo() {
    noBtn.style.display = "inline-block";
    noBtn.style.visibility = "visible";
    noBtn.style.opacity = "1";
    noBtn.style.pointerEvents = "auto";
  }
  forceVisibleNo();

  function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

  // Keep NO well inside the screen (extra safe padding), never out of frame
  function safeBounds() {
    const r = noBtn.getBoundingClientRect();
    const pad = Math.max(18, Math.round(Math.min(window.innerWidth, window.innerHeight) * 0.07)); // ~7% padding
    const maxX = window.innerWidth  - r.width  - pad;
    const maxY = window.innerHeight - r.height - pad;
    return { pad, maxX: Math.max(pad, maxX), maxY: Math.max(pad, maxY), w: r.width, h: r.height };
  }

  function teleportNo(biasPoint = null) {
    forceVisibleNo();

    const { pad, maxX, maxY, w, h } = safeBounds();
    const tiny = (window.innerWidth < 380 || window.innerHeight < 650);

    let x, y;

    if (biasPoint && Number.isFinite(biasPoint.x) && Number.isFinite(biasPoint.y)) {
      // Pick a region away from pointer (opposite quadrant), with fallbacks
      const pointerOnRight = biasPoint.x > window.innerWidth / 2;
      const pointerOnBottom = biasPoint.y > window.innerHeight / 2;

      const leftRegion  = { minX: pad, maxX: window.innerWidth * 0.45 - w };
      const rightRegion = { minX: window.innerWidth * 0.55, maxX: window.innerWidth - w - pad };
      const topRegion   = { minY: pad, maxY: window.innerHeight * 0.45 - h };
      const botRegion   = { minY: window.innerHeight * 0.55, maxY: window.innerHeight - h - pad };

      const xr = pointerOnRight ? leftRegion : rightRegion;
      const yr = pointerOnBottom ? topRegion : botRegion;

      let minX = clamp(xr.minX, pad, maxX);
      let maxX2 = clamp(xr.maxX, pad, maxX);
      let minY = clamp(yr.minY, pad, maxY);
      let maxY2 = clamp(yr.maxY, pad, maxY);

      // If region collapses (small screen), fall back to a central band
      if (maxX2 <= minX + 5 || maxY2 <= minY + 5) {
        const bandPadX = tiny ? pad : Math.round(window.innerWidth * 0.12);
        const bandPadY = tiny ? pad : Math.round(window.innerHeight * 0.14);

        minX = clamp(bandPadX, pad, maxX);
        maxX2 = clamp(window.innerWidth - w - bandPadX, pad, maxX);
        minY = clamp(bandPadY, pad, maxY);
        maxY2 = clamp(window.innerHeight - h - bandPadY, pad, maxY);
      }

      x = minX + Math.random() * Math.max(1, (maxX2 - minX));
      y = minY + Math.random() * Math.max(1, (maxY2 - minY));
    } else {
      // Default: comfortable central band
      const bandPadX = tiny ? pad : Math.round(window.innerWidth * 0.12);
      const bandPadY = tiny ? pad : Math.round(window.innerHeight * 0.14);

      const minX = clamp(bandPadX, pad, maxX);
      const maxX2 = clamp(window.innerWidth - w - bandPadX, pad, maxX);
      const minY = clamp(bandPadY, pad, maxY);
      const maxY2 = clamp(window.innerHeight - h - bandPadY, pad, maxY);

      x = minX + Math.random() * Math.max(1, (maxX2 - minX));
      y = minY + Math.random() * Math.max(1, (maxY2 - minY));
    }

    x = clamp(x, pad, maxX);
    y = clamp(y, pad, maxY);

    noBtn.style.left = `${x}px`;
    noBtn.style.top  = `${y}px`;
  }

  function pointFromEvent(e) {
    if (!e) return { x: window.innerWidth/2, y: window.innerHeight/2 };
    if (e.touches && e.touches[0]) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    if (Number.isFinite(e.clientX) && Number.isFinite(e.clientY)) return { x: e.clientX, y: e.clientY };
    return { x: window.innerWidth/2, y: window.innerHeight/2 };
  }

  // Initial placement + reinforce visibility
  teleportNo();
  setTimeout(teleportNo, 50);

  // Keep inside bounds on resize/orientation
  window.addEventListener("resize", () => teleportNo());
  window.addEventListener("orientationchange", () => setTimeout(() => teleportNo(), 220));

  // Throttle moves so it doesn't feel too fast
  let lastMove = 0;
  const MIN_MOVE_GAP_MS = 320;

  function tryEvade(e) {
    const now = Date.now();
    if (now - lastMove < MIN_MOVE_GAP_MS) return;
    lastMove = now;
    teleportNo(pointFromEvent(e));
  }

  noBtn.addEventListener("mouseenter", tryEvade);
  noBtn.addEventListener("pointerdown", (e) => { e.preventDefault(); tryEvade(e); });
  noBtn.addEventListener("touchstart", (e) => { e.preventDefault(); tryEvade(e); }, { passive:false });
  noBtn.addEventListener("click", (e) => { e.preventDefault(); tryEvade(e); });

  // If pointer comes near it (desktop), move gently
  document.addEventListener("pointermove", (e) => {
    const r = noBtn.getBoundingClientRect();
    const cx = r.left + r.width/2, cy = r.top + r.height/2;
    const dist = Math.hypot(e.clientX - cx, e.clientY - cy);
    if (dist < 90) tryEvade(e);
  });

  // -------- Party popper burst (before modal) --------
  function partyPopperBurst() {
    const emojis = ["üéâ","üéä","ü™©","‚ú®","üíñ","üíò","ü•≥","üéà"];
    const count = 18;

    for (let i = 0; i < count; i++) {
      const s = document.createElement("div");
      s.className = "burst";
      s.textContent = emojis[Math.floor(Math.random()*emojis.length)];

      const angle = (Math.PI * 2) * (i / count) + (Math.random() * 0.4);
      const radius = 140 + Math.random() * 120;
      const dx = Math.cos(angle) * radius;
      const dy = Math.sin(angle) * radius;

      s.style.setProperty("--dx", `${dx}px`);
      s.style.setProperty("--dy", `${dy}px`);
      s.style.animation = `pop ${650 + Math.random()*250}ms ease-out forwards`;

      document.body.appendChild(s);
      s.addEventListener("animationend", () => s.remove());
    }
  }

  // YES flow: poppers + hearts confetti, then show message
  yesBtn.addEventListener("click", () => {
    partyPopperBurst();
    startHeartsConfetti();
    // show message after the popper effect
    setTimeout(() => modal.classList.add("show"), 650);
  });

  closeBtn.addEventListener("click", () => modal.classList.remove("show"));
  modal.addEventListener("click", (e) => { if (e.target === modal) modal.classList.remove("show"); });

  // --- Heart confetti (canvas) ---
  const canvas = document.getElementById("confetti");
  const ctx = canvas.getContext("2d");
  let animId = null;

  function resizeCanvas() {
    const dpr = devicePixelRatio || 1;
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  let hearts = [];
  const heartColors = ["#ff4d7d","#ff1f5a","#ff7aa2","#ffd1dc","#ffffff"];

  function makeHeartPath(x, y, size, rot) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rot);
    ctx.scale(size, size);
    ctx.beginPath();
    ctx.moveTo(0, -0.3);
    ctx.bezierCurveTo(0.45, -0.75, 1.1, -0.1, 0, 0.85);
    ctx.bezierCurveTo(-1.1, -0.1, -0.45, -0.75, 0, -0.3);
    ctx.closePath();
    ctx.restore();
  }

  function spawnHearts(count = 190) {
    hearts = [];
    for (let i = 0; i < count; i++) {
      hearts.push({
        x: Math.random() * window.innerWidth,
        y: -20 - Math.random() * window.innerHeight * 0.6,
        vy: 2 + Math.random() * 4.5,
        vx: (Math.random() - 0.5) * 1.2,
        size: 8 + Math.random() * 10,
        rot: Math.random() * Math.PI,
        vr: (Math.random() - 0.5) * 0.08,
        color: heartColors[Math.floor(Math.random() * heartColors.length)],
        alpha: 0.9 + Math.random() * 0.1
      });
    }
  }

  function draw() {
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    for (const h of hearts) {
      h.x += h.vx + Math.sin(h.y * 0.02) * 0.3;
      h.y += h.vy;
      h.rot += h.vr;

      ctx.globalAlpha = h.alpha;
      ctx.fillStyle = h.color;

      makeHeartPath(h.x, h.y, h.size / 20, h.rot);
      ctx.fill();

      if (h.y > window.innerHeight + 40) {
        h.y = -20 - Math.random() * 120;
        h.x = Math.random() * window.innerWidth;
      }
    }
    ctx.globalAlpha = 1;
    animId = requestAnimationFrame(draw);
  }

  function startHeartsConfetti() {
    spawnHearts(210);
    if (animId) cancelAnimationFrame(animId);
    draw();

    setTimeout(() => {
      if (animId) cancelAnimationFrame(animId);
      animId = null;
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    }, 6500);
  }
</script>
</body>
</html>
```
